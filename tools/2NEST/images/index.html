<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Firecast Visualization</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    body {margin:0;padding:0;font-family:sans-serif;}
    #sidebar { width:300px; height:100vh; float:left; overflow-y:auto;
               background:#f7f7f7; border-right:1px solid #ccc;
               padding:10px; box-sizing:border-box; }
    #map { margin-left:300px; height:100vh; }
    .param-button, .step-button { display:block; width:100%;
      padding:8px; margin:5px 0; border:1px solid #ccc;
      background:#fff; cursor:pointer; text-align:left;
      box-sizing:border-box; }
    .active { background:#e0e0e0; }
    #controls { margin-top:10px; text-align:center; }
    #controls button { padding:6px 12px; margin:0 5px; cursor:pointer; }
    #colorbar-container { margin-top:20px; }
    /* NEW: Video controller area */
    #videoController { margin-top:20px; }
    #videoController video { width:100%; display:block; margin:auto; }
  </style>
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <!-- JSZip & toGeoJSON -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://unpkg.com/@mapbox/togeojson@0.16.2/togeojson.js"></script>
  <!-- Leaflet-Velocity -->
  <script src="leaflet-velocity.js"></script>
</head>
<body>
  <div id="sidebar">
    <h3>Parameters</h3>
    <div id="topControls" style="display:flex; align-items:center;">
      <div id="colorbar-container" style="margin-right:10px;"></div>
      <div id="parameterList" style="flex:1;"></div>
    </div>
    <div id="videoController"></div>
    <div id="controls">
      <button id="prevStep">Previous</button>
      <button id="nextStep">Next</button>
    </div>
    <label style="display:block; margin:5px 0;">
      <input type="checkbox" id="vectorToggle" checked>
      Use Vectors
    </label>
    <label style="display:block; margin:5px 0;">
      <input type="checkbox" id="windToggle" checked>
      Show Wind Overlay
    </label>
    <label style="display:block; margin:5px 0;">
      <input type="checkbox" id="videoToggle" checked>
      Use Video Overlay
    </label>
    <h3>Steps</h3>
    <div id="stepList"></div>
  </div>
  <div id="map"></div>

  <script>
    const FRAMERATE = 30; // frames per second for video controls
    /* Parameters object with updated colormap settings.
       Note: fronts now use geojson files.
    */
 
    const parameters = {
      "fronts": {
        ext: "geojson",
        steps: Array.from({length: 14}, (v, i) => i)  // 0 to 13
      },
      "plumeBottomHeight": {
        ext: "kmz",
        colorbar: "turbo.png",
        min: 0,
        max: 5000,
        unit: "meters",
        steps: Array.from({length: 14}, (v, i) => i + 1)  // 1 to 14
      },
      "plumeTopHeight": {
        ext: "kmz",
        colorbar: "turbo.png",
        min: 0,
        max: 5000,
        unit: "meters",
        steps: Array.from({length: 14}, (v, i) => i + 1)
      },
      "smokeAtGround": {
        ext: "kmz",
        colorbar: "turbo.png",
        min: 0,
        max: 0.01,
        unit: "relative mass",
        steps: Array.from({length: 14}, (v, i) => i + 1)
      },
      "speed": {
        ext: "kmz",
        colorbar: "turbo.png",
        min: 0,
        max: 1,
        unit: "m/s",
        steps: Array.from({length: 14}, (v, i) => i + 1)
      },
      "tke": {
        ext: "kmz",
        colorbar: "turbo.png",
        min: 0,
        max: 3,
        unit: "m/s",
        steps: Array.from({length: 14}, (v, i) => i + 1)
      },
      "wind": {
        ext: "kmz",
        colorbar: "turbo.png",
        min: 0,
        max: 10,
        unit: "m/s",
        steps: Array.from({length: 14}, (v, i) => i + 1)
      }
    };

    let currentParameter = "fronts";
    let currentStepIndex = 0; // current step index (preserved across parameter changes)
    let currentLayer = null;
    let velocityLayer = null;
    let useVectors = true;
    let showWind = true;
    let useVideo = true;
    let speedTimestamps = [];
    let speedTimestampsLoaded = false;
    // Preload speed timestamps at startup
    Promise.all(parameters.speed.steps.map(step =>
      getTimestampFromKMZ(`speed_${step}.kmz`).catch(() => null)
    )).then(results => {
      speedTimestamps = results;
      speedTimestampsLoaded = true;
      buildStepList();
    }).catch(e => console.error("Error preloading speed timestamps:", e));
    // Initialize the map with a default view
    const map = L.map('map').setView([42.17, 9.17], 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const parameterListDiv = document.getElementById("parameterList");
    const stepListDiv = document.getElementById("stepList");
    const colorbarContainer = document.getElementById("colorbar-container");
    const prevStepButton = document.getElementById("prevStep");
    const nextStepButton = document.getElementById("nextStep");
    const videoController = document.getElementById("videoController");
    const windToggle = document.getElementById("windToggle");
    const videoToggle = document.getElementById("videoToggle");
    // Update the colorbar display if the current parameter has one.
    function updateColorbarDisplay() {
      const paramConfig = parameters[currentParameter];
      if (paramConfig.colorbar) {
        colorbarContainer.innerHTML = `
          <div style="text-align: center; font-size: 12px;">${paramConfig.max}</div>
          <img src="${paramConfig.colorbar}" width="50" height="400" style="display: block; margin: auto;"/>
          <div style="text-align: center; font-size: 12px;">${paramConfig.min}</div>
          <div style="text-align: center; font-size: 12px;">${paramConfig.unit}</div>
        `;
      } else {
        colorbarContainer.innerHTML = "";
      }
    }

    // Build the parameter selection list.
    function buildParameterList() {
      parameterListDiv.innerHTML = "";
      Object.keys(parameters).forEach(param => {
        const btn = document.createElement("button");
        btn.textContent = param;
        btn.className = "param-button" + (param === currentParameter ? " active" : "");
        btn.onclick = () => {
          currentParameter = param;
          // Preserve the current step if possible
          currentStepIndex = Math.min(currentStepIndex, parameters[currentParameter].steps.length - 1);
          updateParameterSelection();
          updateColorbarDisplay();
          loadCurrentFile();
        };
        parameterListDiv.appendChild(btn);
      });
    }

    // Build the steps list with labels.
    function buildStepList() {
      stepListDiv.innerHTML = "";
      const steps = parameters[currentParameter].steps;
      steps.forEach((step, index) => {
        const btn = document.createElement("button");
        btn.className = "step-button" + (index === currentStepIndex ? " active" : "");
        // For "speed" and "wind" parameters, fetch timestamp from file.
        let label;
        if (speedTimestampsLoaded) {
          const ts = speedTimestamps[index];
          if (ts === null) return;       // skip if no timestamp
          label = ts;
        } else {
          label = `Hour ${step}`;
        }
          btn.textContent = label;
         // btn.textContent = "Step " + step;
        
        btn.onclick = () => {
          currentStepIndex = index;
          updateStepSelection();
          loadCurrentFile();
        };
        stepListDiv.appendChild(btn);
      });
   
    }

    function updateParameterSelection() {
      Array.from(parameterListDiv.children).forEach(btn => {
        btn.classList.toggle("active", btn.textContent === currentParameter);
      });
      buildStepList();
    }

    function updateStepSelection() {
      Array.from(stepListDiv.children).forEach((btn, index) => {
        btn.classList.toggle("active", index === currentStepIndex);
      });
    }

    prevStepButton.onclick = () => {
      if (currentStepIndex > 0) {
        currentStepIndex--;
        updateStepSelection();
        loadCurrentFile();
      }
    };

    nextStepButton.onclick = () => {
      if (currentStepIndex < parameters[currentParameter].steps.length - 1) {
        currentStepIndex++;
        updateStepSelection();
        loadCurrentFile();
      }
    };
    const vectorToggle = document.getElementById("vectorToggle");
    vectorToggle.addEventListener("change", () => {
      useVectors = vectorToggle.checked;
      loadCurrentFile();
    });
    windToggle.addEventListener("change", () => {
      showWind = windToggle.checked;
      // if disabling, remove any existing wind layer
      if (!showWind && velocityLayer) {
        map.removeLayer(velocityLayer);
        velocityLayer = null;
      }
      loadCurrentFile();
    });
    videoToggle.addEventListener("change", () => {
      useVideo = videoToggle.checked;
      loadCurrentFile();
    });

    // Function to extract timestamp from a KMZ file (for "speed" parameter).
    function getTimestampFromKMZ(filename) {
      return fetch(filename)
        .then(response => response.arrayBuffer())
        .then(data => JSZip.loadAsync(data))
        .then(zip => {
          let kmlFileName = null;
          zip.forEach((relativePath, zipEntry) => {
            if (relativePath.endsWith(".kml") && !kmlFileName) {
              kmlFileName = relativePath;
            }
          });
          if (!kmlFileName) {
            throw new Error("No KML file found in KMZ.");
          }
          return zip.file(kmlFileName).async("text");
        })
        .then(kmlText => {
          const parser = new DOMParser();
          const kml = parser.parseFromString(kmlText, "application/xml");
          const timeStampElem = kml.getElementsByTagName("TimeStamp")[0];
          if (timeStampElem) {
            const whenElem = timeStampElem.getElementsByTagName("when")[0];
            if (whenElem) return whenElem.textContent;
          }
          throw new Error("No timestamp found.");
        });
    }

    // Function to extract timestamp from a windCS JSON file (for "wind" parameter).
    function getTimestampFromWindCS(filename) {
      return fetch(filename)
        .then(response => response.json())
        .then(data => {
          if (data.header && data.header.refTime) {
            return data.header.refTime;
          }
          throw new Error("No refTime in windCS JSON.");
        });
    }

    // Load the wind arrow overlay using leaflet-velocity.
    function loadWindLayer(step) {
      if (!showWind) { 
        if (velocityLayer) { map.removeLayer(velocityLayer); velocityLayer = null; }
        return;
      }
      const windFilename = "windCS_" + step + ".json";
      fetch(windFilename)
        .then(resp => resp.json())
        .then(windData => {
          if (velocityLayer) {
            map.removeLayer(velocityLayer);
          }
          velocityLayer = L.velocityLayer({
            displayValues: true,
            displayOptions: {
              velocityType: "Wind",
              position: "bottomleft",
              emptyString: "No velocity data",
              angleConvention: "bearingCW",
              showCardinal: false,
              useVectors: useVectors,
              speedUnit: "ms",
              directionString: "Direction",
              speedString: "Speed"
            },
            data: windData,
            lineWidth: 3,
            minVelocity: parameters.wind.min,
            maxVelocity: parameters.wind.max,
            velocityScale: 0.005,
            opacity: 1,
            paneName: "overlayPane"
          });
          velocityLayer.addTo(map);
        })
        .catch(e => console.error("Error fetching wind data:", e));
    }

    // Load the file corresponding to the current parameter and step.
    function loadCurrentFile() {
      if (currentLayer) {
        map.removeLayer(currentLayer);
        currentLayer = null;
      }
      videoController.innerHTML = "";
      const paramInfo = parameters[currentParameter];
      const step = paramInfo.steps[currentStepIndex];
      let filename = "";
      if (currentParameter === "fronts") {
        filename = "fronts_" + step + ".geojson";
        fetch(filename)
          .then(response => response.json())
          .then(geojson => {
            currentLayer = L.geoJSON(geojson);
            currentLayer.addTo(map);
            if (currentLayer.getBounds && currentLayer.getBounds().isValid()) {
              map.fitBounds(currentLayer.getBounds());
            }
          })
          .catch(err => console.error("Error loading GeoJSON file:", err));
      } else {
        filename = currentParameter + "_" + step + "." + paramInfo.ext;
        fetch(filename)
          .then(response => response.arrayBuffer())
          .then(data => JSZip.loadAsync(data))
          .then(zip => {
            let kmlFileName = null;
            zip.forEach((relativePath, zipEntry) => {
              if (relativePath.endsWith(".kml") && !kmlFileName) {
                kmlFileName = relativePath;
              }
            });
            if (!kmlFileName) {
              throw new Error("No KML file found in KMZ.");
            }
            return Promise.all([
              zip.file(kmlFileName).async("text"),
              Promise.resolve(zip)
            ]);
          })
          .then(([kmlText, zip]) => {
            const parser = new DOMParser();
            const kml = parser.parseFromString(kmlText, "application/xml");
            const groundOverlay = kml.getElementsByTagName("GroundOverlay")[0];
            if (!groundOverlay) throw new Error("No GroundOverlay found.");
            const latLonBox = groundOverlay.getElementsByTagName("LatLonBox")[0];
            const north = parseFloat(latLonBox.getElementsByTagName("north")[0].textContent);
            const south = parseFloat(latLonBox.getElementsByTagName("south")[0].textContent);
            const east = parseFloat(latLonBox.getElementsByTagName("east")[0].textContent);
            const west = parseFloat(latLonBox.getElementsByTagName("west")[0].textContent);
            const bounds = [[south, west], [north, east]];
            const icon = groundOverlay.getElementsByTagName("Icon")[0];
            let href = icon.getElementsByTagName("href")[0].textContent;
            let fileEntry = zip.file(href);
            if (!fileEntry) {
              for (const fname in zip.files) {
                if (fname.toLowerCase() === href.toLowerCase()) {
                  fileEntry = zip.file(fname);
                  break;
                }
              }
            }
            if (fileEntry) {
              return fileEntry.async("blob").then(blob => {
                const imageURL = URL.createObjectURL(blob);
                return { imageURL, bounds };
              });
            } else {
              return { imageURL: href, bounds };
            }
          })
          .then(({ imageURL, bounds }) => {
            const videoUrl = `${currentParameter}.webm`;
      if (useVideo) {
        fetch(videoUrl, { method: 'HEAD' })
          .then(res => {
            if (res.ok) {
              if (currentLayer) map.removeLayer(currentLayer);
              currentLayer = L.videoOverlay(videoUrl, bounds, {
                autoplay: true, loop: true, muted: true
              }).addTo(map);
              const vidEl = currentLayer.getElement();
              videoController.innerHTML = `
                <button id="playPause">Play</button>
                <button id="prevFrame">Prev</button>
                <button id="nextFrame">Next</button>
                <input type="range" id="timeSlider" min="0" max="0" step="${1/FRAMERATE}" value="0" style="width:100%;"/>
              `;
              const playPauseBtn = document.getElementById('playPause');
              const prevFrameBtn = document.getElementById('prevFrame');
              const nextFrameBtn = document.getElementById('nextFrame');
              const timeSlider = document.getElementById('timeSlider');
              vidEl.addEventListener('loadedmetadata', () => {
                timeSlider.max = vidEl.duration;
                playPauseBtn.textContent = vidEl.paused ? 'Play' : 'Pause';
              });
              playPauseBtn.onclick = () => {
                if (vidEl.paused) { vidEl.play(); playPauseBtn.textContent = 'Pause'; }
                else { vidEl.pause(); playPauseBtn.textContent = 'Play'; }
              };
              prevFrameBtn.onclick = () => {
                vidEl.currentTime = Math.max(0, vidEl.currentTime - 1/FRAMERATE);
                timeSlider.value = vidEl.currentTime;
              };
              nextFrameBtn.onclick = () => {
                vidEl.currentTime = Math.min(vidEl.duration, vidEl.currentTime + 1/FRAMERATE);
                timeSlider.value = vidEl.currentTime;
              };
              timeSlider.oninput = () => {
                vidEl.currentTime = timeSlider.value;
              };
            } else {
              currentLayer = L.imageOverlay(imageURL, bounds).addTo(map);
            }
            map.fitBounds(bounds);
          })
          .catch(() => {
            currentLayer = L.imageOverlay(imageURL, bounds).addTo(map);
            map.fitBounds(bounds);
          });
      } else {
        currentLayer = L.imageOverlay(imageURL, bounds).addTo(map);
        map.fitBounds(bounds);
      }

          })
          .catch(err => console.error("Overlay load error:", err));
      }
      // Always load the wind arrow overlay for the current step.
      loadWindLayer(step);
    }

    // Initialize the interface.
    buildParameterList();
    buildStepList();
    updateColorbarDisplay();
    loadCurrentFile();
  </script>
</body>
</html>